<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE section [
<!-- Some useful entities borrowed from HTML -->
<!ENTITY ndash  "&#x2013;">
<!ENTITY mdash  "&#x2014;">
<!ENTITY hellip "&#x2026;">

<!-- Useful for describing APIs -->
<!ENTITY COPY   '<command xmlns="http://docbook.org/ns/docbook">COPY</command>'>
<!ENTITY GET    '<command xmlns="http://docbook.org/ns/docbook">GET</command>'>
<!ENTITY HEAD   '<command xmlns="http://docbook.org/ns/docbook">HEAD</command>'>
<!ENTITY PUT    '<command xmlns="http://docbook.org/ns/docbook">PUT</command>'>
<!ENTITY POST   '<command xmlns="http://docbook.org/ns/docbook">POST</command>'>
<!ENTITY DELETE '<command xmlns="http://docbook.org/ns/docbook">DELETE</command>'>
]>
<section xmlns="http://docbook.org/ns/docbook"
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
    xml:id="storage-object-services">
    <title>Storage object services</title>
    <para>Creates, updates, gets details for, and deletes objects.
        Gets and updates object metadata.</para>
    <para>An object represents the data and metadata for the files
        stored in the system. Through the ReST interface, you can
        include metadata for an object by adding custom HTTP headers
        to the request and the data payload as the request body.
        Objects cannot exceed 5 GB and must have names that do not
        exceed 1024 bytes after URL encoding. However, you can segment
        a large object into 5 GB segments and upload the segments.
        Then, you can download the segments as a single concatenated
        object. You can use HTTP requests to work with the segments
        and manifests directly.</para>
    <wadl:resources xmlns:wadl="http://wadl.dev.java.net/2009/02">
        <wadl:resource
            href="http://git.openstack.org/cgit/openstack/api-site/plain/api-ref/src/wadls/object-api/src/os-object-api-1.0.wadl#object">
            <wadl:method href="#listObjects"/>
            <wadl:method href="#retrieveobject"/>
            <wadl:method href="#createobject"/>
            <wadl:method href="#deleteobject"/>
            <wadl:method href="#copyobject"/>
            <wadl:method href="#retrieveobjectmeta"/>
            <wadl:method href="#updateaobjmeta"/>
        </wadl:resource>
    </wadl:resources>
    <!-- <informaltable rules="all">
        <thead>
            <tr>
                <td colspan="1">Verb</td>
                <td colspan="2">URI</td>
                <td colspan="3">Description</td>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td colspan="1">&GET;</td>
                <td colspan="2"
                        >/<parameter>account</parameter>/<parameter>container</parameter>/<parameter>object</parameter></td>
                <td colspan="3">Gets object details.</td>
            </tr>
            <tr>
                <td colspan="1">&PUT;</td>
                <td colspan="2"
                        >/<parameter>account</parameter>/<parameter>container</parameter>/<parameter>object</parameter></td>
                <td colspan="3">Creates or updates object.</td>
            </tr>
            <tr>
                <td colspan="1">&PUT;</td>
                <td colspan="2"
                        >/<parameter>account</parameter>/<parameter>container</parameter>/<parameter>object</parameter></td>
                <td colspan="3">Chunked transfer encoding.</td>
            </tr>
            <tr>
                <td colspan="1">&DELETE;</td>
                <td colspan="2"
                        >/<parameter>account</parameter>/<parameter>container</parameter>/<parameter>object</parameter></td>
                <td colspan="3">Deletes a specified object.</td>
            </tr>
            <tr>
                <td colspan="1">&HEAD;</td>
                <td colspan="2"
                        >/<parameter>account</parameter>/<parameter>container</parameter>/<parameter>object</parameter></td>
                <td colspan="3">Gets object metadata.</td>
            </tr>
            <tr>
                <td colspan="1">&POST;</td>
                <td colspan="2"
                        >/<parameter>account</parameter>/<parameter>container</parameter>/<parameter>object</parameter></td>
                <td colspan="3">Updates object metadata.</td>
            </tr>
        </tbody>
    </informaltable>
    <variablelist>
        <title>Optional headers for HEAD and GET</title>
        <varlistentry>
            <term><code>X-Newest</code></term>
            <listitem>
                <para>Set the optional <code>X-newest</code> header to
                        <code>True</code> in HEAD and GET requests to
                    have Object Storage return the latest version of
                    the object. If set to <code>True</code>, Object
                    Storage queries all replicas to return the most
                    recent one. Without this header, Object Storage
                    responds faster after it finds one valid replica.
                    Because setting this header to <code>True</code>
                    is more expensive for the back end, use it only
                    when it is absolutely needed.</para>
            </listitem>
        </varlistentry>
    </variablelist>
    <section xml:id="retrieve-object">
        <title>Get Object Details</title>
        <para>Perform &GET; operations against an object to get object
            data.</para>
        <para>You can perform conditional &GET; requests by using the
            following HTTP headers in the request:</para>
        <itemizedlist>
            <listitem>
                <para><literal>If-Match</literal></para>
            </listitem>
            <listitem>
                <para><literal>If-None-Match</literal></para>
            </listitem>
            <listitem>
                <para><literal>If-Modified-Since</literal></para>
            </listitem>
            <listitem>
                <para><literal>If-Unmodified-Since</literal></para>
            </listitem>
        </itemizedlist>
        <para>These headers are documented in <link
                xlink:href="http://www.ietf.org/rfc/rfc2616.txt"
                >http://www.ietf.org/rfc/rfc2616.txt</link>.</para>
        <para>You can use the HTTP <code>Range</code> header to fetch
            portions of data by using one or more range
            specifications. To specify many ranges, separate the range
            specifications with a comma.</para>
        <para>The types of range specifications are:</para>
        <itemizedlist>
            <listitem>
                <para><emphasis role="bold">Byte range
                        specification</emphasis>. Use
                    FIRST_BYTE_OFFSET to specify the start of the data
                    range, and LAST_BYTE_OFFSET to specify the end.
                    You can omit the LAST_BYTE_OFFSET and if you do,
                    the value defaults to the offset of the last byte
                    of data.</para>
            </listitem>
            <listitem>
                <para><emphasis role="bold">Suffix byte range
                        specification</emphasis>. Use LENGTH bytes to
                    specify the length of the data range.</para>
            </listitem>
        </itemizedlist>
        <para>The following forms of the header specify the following
            ranges of data:</para>
        <informaltable rules="all">
            <col width="40%"/>
            <col width="60%"/>
            <thead>
                <tr>
                    <th>Header</th>
                    <th>Range of object data</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>
                        <para><code>Range: bytes=-5</code></para></td>
                    <td><para>The last five bytes.</para>
                    </td>
                </tr>
                <tr>
                    <td><para><code>Range:
                        bytes=10-14</code></para></td>
                    <td>The five bytes of data after a 10-byte
                        offset.</td>
                </tr>
                <tr>
                    <td><para><code>Range:
                            bytes=10-14,-5</code></para></td>
                    <td><para>A multi-part response that contains the five bytes of data after
                            a 10-byte offset and the last five
                            bytes.</para>
                        <para>The <code>Content-Type</code> of the
                            response is then
                                <code>multipart/byteranges</code>.</para>
                    </td>
                </tr>
                <tr>
                    <td>
                        <para><code>Range:
                        bytes=4-6</code></para></td>
                    <td><para>Bytes 4 to 6 inclusive.</para></td>
                </tr>
                <tr>
                    <td>
                        <para><code>Range:
                        bytes=2-2</code></para></td>
                    <td><para>Byte 2, which is the third byte of the data.</para>
                    </td>
                </tr>
                <tr>
                    <td>
                        <para><code>Range: bytes=6-</code></para></td>
                    <td><para>Byte 6 and after.</para>
                    </td>
                </tr>
                <tr>
                    <td>
                        <para><code>Range:
                        bytes=1-3,2-5</code></para></td>
                    <td><para>A multi-part response that contains
                            bytes 1 to 3 inclusive, and bytes 2 to 5
                            inclusive.</para>
                        <para>The <code>Content-Type</code> of the
                            response is then
                                <code>multipart/byteranges</code>.</para>
                    </td>
                </tr>
            </tbody>
        </informaltable>
        <example>
            <title>Get Object Details request: HTTP</title>
            <literallayout class="monospaced"><xi:include href="samples/object-get-req.txt" parse="text"/></literallayout>
        </example>
        <para>The object data is returned in the response body. Object
            metadata is returned as HTTP headers. A status of
                2<replaceable>xx</replaceable> (between 200 and 299,
            inclusive) indicates success; status 404 (Not Found) is
            returned if no such object exists.</para>
        <example>
            <title>Get Object Details response: HTTP</title>
            <literallayout class="monospaced"><xi:include href="samples/object-get-resp.txt" parse="text"/></literallayout>
        </example>
        <para>These examples include an object that contains 10 bytes
            of data: <literal>0123456789</literal>.</para>
        <example>
            <title>Get Object Details request: HTTP Using Range</title>
            <literallayout class="monospaced"><xi:include href="samples/object-get-range-req.txt" parse="text"/></literallayout>
        </example>
        <example>
            <title>Get Object Details response: HTTP When Using
                Range</title>
            <literallayout class="monospaced"><xi:include href="samples/object-get-range-resp.txt" parse="text"/></literallayout>
        </example>
        <example>
            <title>Get Object Details request: HTTP Using Multiple
                Ranges</title>
            <literallayout class="monospaced"><xi:include href="samples/object-get-ranges-req.txt" parse="text"/></literallayout>
        </example>
        <example>
            <title>Get Object Details response: HTTP When Using
                Multiple Ranges</title>
            <literallayout class="monospaced"><xi:include href="samples/object-get-ranges-resp.txt" parse="text"/></literallayout>
        </example>
    </section>
    <section xml:id="create-update-object">
        <title>Create or Update Object</title>
        <para>&PUT; operations are used to write, or overwrite, an
            object's content and metadata.</para>
        <para>You can ensure end-to-end data integrity by including an
            MD5 checksum of your object's data in the ETag header. You
            are not required to include the ETag header, but it is
            recommended to ensure that the storage system successfully
            stored your object's content.</para>
        <para>You can cause an object to expire after a certain date
            by using the <code>X-Delete-At</code> or
                <code>X-Delete-After</code> headers during an object
            &PUT; operation. When Object Storage detects one of these
            headers, the system automatically stops serving that
            object at the specified time and shortly after the
            expiration date, it removes the object from the storage
            system.</para>
        <para>The response: HTTP will include the MD5 checksum of the
            data written to the storage system. If you do not send the
            ETag in the request, you should compare the value returned
            with your content's MD5 locally to perform the end-to-end
            data validation on the client side. For manifest objects,
            the ETag is the MD5 checksum of the concatenated string of
            ETags for each of the segments in the manifest. Refer to
                <link linkend="large-object-creation">Create Large
                Objects</link> for more information.</para>
        <para>Objects can be assigned custom metadata by including
            additional HTTP headers on the &PUT; request.</para>
        <para>The object can be created with custom metadata via HTTP
            headers identified with the <code>X-Object-Meta-</code>
            prefix, or arbitrary headers set with the
                <literal>allowed_headers</literal> option in the
            object-server configuration.</para>
        <example>
            <title>Create or Update Object request: HTTP</title>
            <literallayout class="monospaced"><xi:include href="samples/object-create-req.txt" parse="text"/></literallayout>
            <literallayout class="monospaced">[ ... ]</literallayout>
        </example>
        <para>No response body is returned. A status code of 201
            (Created) indicates a successful write; status 411 (Length
            Required) denotes a missing <code>Content-Length</code> or
                <code>Content-Type</code> header in the request. If
            the MD5 checksum of the data written to the storage system
            does NOT match the (optionally) supplied ETag value, a 422
            (Unprocessable Entity) response is returned.</para>
        <example>
            <title>Create or Update Object response: HTTP</title>
            <literallayout class="monospaced"><xi:include href="samples/object-create-resp.txt" parse="text"/></literallayout>
        </example>
        <section xml:id="chunked-transfer-encoding">
            <title>Chunked Transfer Encoding</title>
            <para>Users can upload data without needing to know in
                advance the amount of data to be uploaded. Users can
                do this by specifying an HTTP header of
                    <code>Transfer-Encoding: chunked</code> and not
                using a <code>Content-Length</code> header. A good use
                of this feature would be doing a DB dump, piping the
                output through gzip, then piping the data directly
                into OpenStack Object Storage without having to buffer
                the data to disk to compute the file size. If users
                attempt to upload more than 5GB with this method, the
                server will close the TCP/IP connection after 5GB and
                purge the customer data from the system. Users must
                take responsibility for ensuring the data they
                transfer will be less than 5GB or for splitting it
                into 5GB chunks, each in its own storage object. If
                you have files that are larger than 5GB see <xref
                    linkend="large-object-creation"/>.</para>
            <example>
                <title>Upload Unspecified Quantity of Contentrequest: HTTP</title>
                <literallayout class="monospaced"><xi:include href="samples/chunked-transfer-encoding-req.txt" parse="text"/></literallayout>
            </example>
            <example>
                <title>Upload Unspecified Quantity of Content HTTP
                    Response</title>
                <literallayout class="monospaced"><xi:include href="samples/chunked-transfer-encoding-resp.txt" parse="text"/></literallayout>
            </example>
        </section>
    </section>-->
    <!-- large object creation -->
    <!-- cors headers -->
    <!-- file compression -->
    <!-- browser bypass -->
    <!-- expire object -->
    <!-- object versioning -->
    <!--  <section xml:id="copy-object">
        <title>Copy Object</title>
        <para>Suppose you upload a file with the wrong object name or
            content type, or you needed to move some objects to
            another container. Without a server-side copy feature, you
            would need to repeat uploading the same content and then
            delete the existing object. With server-side object copy,
            you can save the step of re-uploading the content and thus
            also save the associated bandwidth charges, if any were to
            apply.</para>
        <para>There are two ways to copy an existing object to another
            object in OpenStack Object Storage. One way is to do a
            &PUT; to the new object (the target) location, but add the
                <code>“X-Copy-From”</code> header to designate the
            source of the data. The header value should be the
            container and object name of the source object in the form
            of “/container/object”. The container and object name must
            be UTF-8 encoded and then URL-encoded. Also, the
                <code>X-Copy-From</code> &PUT; requests require a
            Content-Length header, even if it is zero (0).</para>
        <example>
            <title>Object Copy Method 1</title>
            <literallayout class="monospaced"><xi:include href="samples/object-copy-1-req.txt" parse="text"/></literallayout>
        </example>
        <para>The second way to do an object copy is similar. Do a
            &COPY; to the existing object, and include the
            “Destination” header to specify the target of the copy.
            The header value is the container and new object name in
            the form of “/container/object”.</para>
        <example>
            <title>Object Copy Method 2</title>
            <literallayout class="monospaced"><xi:include href="samples/object-copy-2-req.txt" parse="text"/></literallayout>
        </example>
        <para>With both of these methods, the destination container
            must exist before attempting the copy.</para>
        <para>If the source object is a manifest object, i.e., an
            object with <code>X-Object-Manifest</code> or
                <code>X-Static-Large-Object:true</code> metadata, the
            copy operation concatenates the segment objects when
            making the content for the destination object. You cannot
            copy an object larger than 5GB (by default). Refer to
                <link linkend="large-object-creation">Large Object
                Creation</link> for more information about large
            objects.</para>
        <para>However, for a <link linkend="static-large-objects"
                >Static Large Object</link> manifest, it is possible
            to copy the manifest so that the destination becomes a
            manifest object. Use the
                <code>?multipart-manifest=get</code> query string to
            indicate that you want a copy of the manifest object. The
            new object will contain the same manifest as the original.
            The segment objects are not copied. Instead, both the
            original and new manifest objects share the same set of
            segment objects.</para>
        <para>If you wanted to move the object rather than copy it,
            you need to send a &DELETE; request to the old object. A
            move is simply a &COPY; + &DELETE;. All metadata is
            preserved during the object copy. Note that you can set
            metadata on the request to copy the object (either the
            &PUT; or the &COPY;) and the metadata will overwrite any
            conflicting keys on the target (new) object. One
            interesting use case is to copy an object to itself and
            set the content type to a new value. This is the only way
            to change the content type of an existing object.</para>
    </section>
    <section xml:id="delete-object">
        <title>Delete Object</title>
        <para>&DELETE; operations on an object are used to permanently
            remove an object from the storage system (metadata and
            data).</para>
        <para>Deleting an object is processed immediately at the time
            of the request. Any subsequent &GET;, &HEAD;, &POST;, or
            &DELETE; operations will return a 404 (Not Found)
            error.</para>
        <para>For <link linkend="static-large-objects">static large
                object manifests</link>, you can add the query
            parameter <code>?multipart-manifest=delete</code>. The
            segment objects are deleted and if all are successfully
            deleted, the manifest object is also deleted.</para>
        <para>Objects with the <code>X-Delete-At</code> or
                <code>X-Delete-After</code> header assigned are
            deleted within one day of the expiration time and the
            object is not served immediately after the expiration
            time. Refer to <link linkend="Expiring_Objects-e1e3228"
                >Expiring Objects</link> for more details.</para>
        <example>
            <title>Object Delete request: HTTP</title>
            <literallayout class="monospaced"><xi:include href="samples/object-delete-req.txt" parse="text"/></literallayout>
        </example>
        <para>No response body is returned. A status code of 2xx (
            between 200 and 299, inclusive) indicates success; status
            code 404 (Not Found) is returned when the object does not
            exist.</para>
        <example>
            <title>Object Delete response: HTTP</title>
            <literallayout class="monospaced"><xi:include href="samples/object-delete-resp.txt" parse="text"/></literallayout>
        </example>
    </section>
    <section xml:id="retrieve-object-metadata">
        <title>Get Object Metadata</title>
        <para>&HEAD; operations on an object are used to retrieve
            object metadata and other standard HTTP headers.</para>
        <para>The only required header to be sent in the request is
            the authorization token.</para>
        <example>
            <title>Get Object Metadata request: HTTP</title>
            <literallayout class="monospaced"><xi:include href="samples/object-metadata-req.txt" parse="text"/></literallayout>
        </example>
        <para>No response body is returned. Metadata is returned as
            HTTP headers. A status code of 2xx (between 200 and 299,
            inclusive) indicates success; status 404 (Not Found) is
            returned when the object does not exist.</para>
        <example>
            <title>Get Object Metadata response: HTTP</title>
            <literallayout class="monospaced"><xi:include href="samples/object-metadata-resp.txt" parse="text"/></literallayout>
        </example>
    </section>
    <section xml:id="update-object-metadata">
        <title>Update Object Metadata</title>
        <para>&POST; operations against an object name are used to set
            and overwrite arbitrary key/value metadata or to assign
            headers not already assigned such as
                <code>X-Delete-At</code> or
                <code>X-Delete-After</code> for expiring objects. You
            cannot use the &POST; operation to change any of the
            object's other headers such as <code>Content-Type</code>,
                <code>ETag</code>, etc. It is not used to upload
            storage objects (see &PUT;). Also refer to <link
                linkend="copy-object">copying an object</link> when
            you need to update metadata or other headers such as
            Content-Type or CORS headers.</para>
        <para>Key names must be prefixed with
                <code>X-Object-Meta-</code>. A &POST; request will
            delete all existing metadata added with a previous
            &PUT;/&POST;.</para>
        <example>
            <title>Update Object Metadata request: HTTP</title>
            <literallayout class="monospaced"><xi:include href="samples/object-update-metadata-req.txt" parse="text"/></literallayout>
        </example>
        <para>No response body is returned. A status code of 2xx
            (between 200 and 299, inclusive) indicates success; status
            404 (Not Found) is returned if the requested object does
            not exist.</para>
        <example>
            <title>Update Object Metadata response: HTTP</title>
            <literallayout class="monospaced"><xi:include href="samples/object-update-metadata-resp.txt" parse="text"/></literallayout>
        </example>
    </section>-->
</section>
